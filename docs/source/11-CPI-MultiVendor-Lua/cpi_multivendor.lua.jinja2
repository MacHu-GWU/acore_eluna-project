--[[
这个脚本用于让玩家通过跟特定 NPC 对话, 打开购买物品的菜单.
--]]

--[[
------------------------------------------------------------------------------
Define Constants
------------------------------------------------------------------------------
--]]

--[[
EVENT_CODE

所有我们这个脚本用到的 event.

Reference:

- RegisterCreatureGossipEvent: https://www.azerothcore.org/pages/eluna/Global/RegisterCreatureGossipEvent.html
--]]
local GOSSIP_EVENT_ON_HELLO = 1
local GOSSIP_EVENT_ON_SELECT = 2

--[[
下面是所有跟业务逻辑有关的常量.
--]]
local NPC_TEXT_ID_1 = 1 -- Greetings, $n
local CPI_VENDOR_ENTRY = 5005001 -- 这个 NPC flag 需要是 129
local EMPTY_SENDER = 0 -- 用于标识没有 sender 的情况
local ROOT_VENDOR_DATA_PARENT_ID = 0 -- 如果一个菜单没有 parent, 那么它的 PARENT_ID 属性的值就是这个

--[[
下面是所有 ICON 代码的枚举. 你可以在 "OptionIcon" 一节中看到所有图标的说明.
See: https://www.azerothcore.org/wiki/gossip_menu_option
--]]
local GOSSIP_ICON_TALK = 7

--[[
这是我们所有跟 vendor 相关的逻辑的 namespace table. 它类似于面向对象中的类一样, 有属性也有方法.

例如后面的 CpiMultiVendor.OnGossip() 就是一个方法.
--]]
local CpiMultiVendor = {}

--[[
VENDOR_DATA_MAPPER

这个变量是最终展现给玩家的菜单的数据容器. 它是类似于一个 Python 字典的结构. 其中 key 是
vendorData 的唯一 ID, value 是 vendorData 本身.

{
    1: { id = 1, name = "...", is_menu = ..., icon = ..., parent = ..., data = { npc_id = ... } },
    2: { id = 1, name = "...", is_menu = ..., icon = ..., parent = ..., data = { npc_id = ... } },
    ...
}
--]]
CpiMultiVendor.VENDOR_DATA_MAPPER = {
{{ lua_code }}
}

function CpiMultiVendor.FindIdByKeyValue(vendorDataMapper, vendorDataKey, vendorDataValue)
    --[[
    这个函数的目的是查找第一个 key, value pair 符合条件的 vendorData 的 ID.

    类似于 ``SELECT ID FROM table WHERE table.vendorDataKey = vendorDataValue LIMIT 1``.

    :type vendorDataMapper: table
    :param vendorDataMapper: 一个 {ID: vendorData} 的字典, 其中 ID 是整数.
    :type vendorDataKey: string
    :param vendorDataKey: vendorData 中的 key
    :type vendorDataKey: any
    :param vendorDataValue: vendorData 中的 value

    :return: 符合条件的 vendorData 的 ID.
    --]]
    for vendorDataId, vendorData in pairs(vendorDataMapper) do
        if vendorDataKey then
            if vendorData[vendorDataKey] == vendorDataValue then
                return vendorDataId
            end
        else -- 貌似无论如何都不会进入到这段逻辑中
            if vendorData == vendorDataValue then
                return vendorDataId
            end
        end
    end
end

function CpiMultiVendor.FindAllByKeyValue(vendorDataMapper, vendorDataKey, vendorDataValue)
    --[[
    这个函数的目的是查找所有 key, value pair 符合条件的 vendorData 的列表.

    类似于 ``SELECT ID FROM table WHERE talbe.vendorDataKey = vendorDataValue``.

    :type vendorDataMapper: table
    :param vendorDataMapper: 一个 {ID: vendorData} 的字典, 其中 ID 是整数.
    :type vendorDataKey: string
    :param vendorDataKey: vendorData 中的 key
    :type vendorDataKey: any
    :param vendorDataValue: vendorData 中的 value

    :return: 符合条件的所有 vendorData 的列表.
    --]]
    local vendorDataList = {}
    -- 注: 这里必须用 ipairs, 确保顺序和定义的顺序一致
    for vendorDataId, vendorData in ipairs(vendorDataMapper) do
        if vendorDataKey then
            if vendorData[vendorDataKey] == vendorDataValue then
                table.insert(vendorDataList, vendorData)
            end
        else
            if vendorData == vendorDataValue then
                table.insert(vendorDataList, vendorData)
            end
        end
    end
    return vendorDataList
end

function CpiMultiVendor.BuildMenu(sender, player, parentVendorDataId)
    --[[
    这个函数会是我们用来构建菜单的自定义函数.
    --]]

    --[[
    1. 先根据当前给定的 parentVendorDataId 找到所有的子菜单. 如果 parentVendorDataId 是 0,
    那么就是最顶层的菜单.
    --]]
    --print("Start: CpiMultiVendor.BuildMenu() function") -- for debug only
    --print(string.format("sender = %s", sender))
    --print(string.format("player = %s", player))
    --print(string.format("parentVendorDataId = %s", parentVendorDataId))
    local args = {
        vendorDataMapper = CpiMultiVendor.VENDOR_DATA_MAPPER,
        vendorDataKey = "parent",
        vendorDataValue = parentVendorDataId,
    }
    local vendorDataList = CpiMultiVendor.FindAllByKeyValue(
        args.vendorDataMapper,
        args.vendorDataKey,
        args.vendorDataValue
    )

    --[[
    这后面的代码会频繁调用 Player:GossipMenuAddItem(...)

    Player:GossipMenuAddItem 方法用于给 Player 当前的 gossip menu 添加一个 item
    (一个 item 就是一个对话面板上可点击的按钮). 这个方法最多接受 7 个参数, 在我们的脚本里
    我们只用到了 4 个.

    :param icon (number): Number that specifies used icon.
        Valid numbers: integers from 0 to 4,294,967,295.
    :param msg (string): Label on the gossip item.
    :param sender (number): Number passed to gossip handlers.
        Valid numbers: integers from 0 to 4,294,967,295.
        通常用于识别谁触发了这个 gossip 选项, 我们这里不需要区分, 所以永远传 0.
    :param intid (number): Number passed to gossip handlers.
        Valid numbers: integers from 0 to 4,294,967,295.

    Ref: https://www.azerothcore.org/pages/eluna/Player/GossipMenuAddItem.html
    --]]
    for _, vendorData in ipairs(vendorDataList) do
        print(string.format("msg = %s", vendorData.name)) -- for debug only
        args = {
            icon = vendorData.icon,
            msg = vendorData.name,
            sender = EMPTY_SENDER,
            intid = vendorData.id -- 这个 item 的唯一 ID
        }
        player:GossipMenuAddItem(
            args.icon,
            args.msg,
            args.sender,
            args.intid
        )
    end

    --[[
    2. 如果 parentVendorDataId 大于 0, 说明我们在一个子菜单中, 那么我们需要添加一个返回上一级菜单的选项.
    --]]
    if parentVendorDataId > 0 then
        --print("This is a submenu, add return button") -- for debug only
        args = {
            vendorDataMapper = CpiMultiVendor.VENDOR_DATA_MAPPER,
            vendorDataKey = "id",
            vendorDataValue = parentVendorDataId,
        }
        local vendorDataId = CpiMultiVendor.FindIdByKeyValue(
            args.vendorDataMapper,
            args.vendorDataKey,
            args.vendorDataValue
        )

        args = {
            icon = GOSSIP_ICON_TALK,
            msg = string.format("< 返回 %s", CpiMultiVendor.VENDOR_DATA_MAPPER[parentVendorDataId].name),
            sender = EMPTY_SENDER,
            intid = CpiMultiVendor.VENDOR_DATA_MAPPER[vendorDataId].parent,
        }
        player:GossipMenuAddItem(
            args.icon,
            args.msg,
            args.sender,
            args.intid
        )

        args = {
            icon = GOSSIP_ICON_TALK,
            msg = "<<< 回到初始菜单",
            sender = EMPTY_SENDER,
            intid = ROOT_VENDOR_DATA_PARENT_ID,
        }
        player:GossipMenuAddItem(
            args.icon,
            args.msg,
            args.sender,
            args.intid
        )
    end

    --[[
     Player:GossipSendMenu 方法可以用来发送菜单给玩家. 它的参数列表如下:

    :type npc_text: number
    :param npc_text: Entry ID of a header text in npc_text database table, common default is 100.
        Valid numbers: integers from 0 to 4,294,967,295.
    :type sender: Object
    :param sender: Object acting as the source of the sent gossip menu.
    :type menu_id: number
    :param menu_id: If sender is a Player then menu_id is mandatory.
        Valid numbers: integers from 0 to 4,294,967,295.

    See: https://www.azerothcore.org/pages/eluna/Player/GossipSendMenu.html
    --]]
    args = {
        npc_text = NPC_TEXT_ID_1,
        sender = sender,
    }
    player:GossipSendMenu(
        args.npc_text,
        args.sender
        -- menu sender is a creature, so we don't need menu_id
    )
    --print("End: CpiMultiVendor.BuildMenu() function") -- for debug only
end


function CpiMultiVendor.OnGossip(event, player, creature, sender, intid, code, menu_id)
    --[[
    这个函数被用于处理 Global:RegisterPlayerGossipEvent@GOSSIP_EVENT_ON_SELECT event.

    在其他例子中你可能会看到还有一个相关的函数 Global:RegisterPlayerGossipEvent@GOSSIP_EVENT_ON_HELLO event
    用于处理玩家的第一次打开 gossip 菜单的情况. 但是在这个例子中, 打开菜单的动作是通过
    Player:GossipSendMenu() 方法在 CpiMultiVendor.OnChat() 中手动用代码
    运行的, 而不是通过游戏中 Player 与人互动. 所以我们不会需要处理这个 event. 但这里我们还是
    将它的参数列表文档列出来, 供你了解.

    Global:RegisterPlayerGossipEvent@GOSSIP_EVENT_ON_HELLO 的参数列表:

    :param event:
    :param player (Object):
    :param object (Object): the Creature/GameObject/Item/Player
        这是玩家正在与之交互的对象. 它可以是:
        - Creature (NPC)
        - GameObject (游戏中的物体, 如邮箱, 宝箱等)
        - Item (物品, 如可以右键点击打开菜单的任务物品)
        - Player (在玩家之间的 gossip 交互中)

    Global:RegisterPlayerGossipEvent@GOSSIP_EVENT_ON_SELECT 的参数列表:

    :param event:
    :param player (Object):
    :param object (Object): the Creature/GameObject/Item/Player
        这是玩家正在与之交互的对象. 它可以是:
        - Creature (NPC)
        - GameObject (游戏中的物体, 如邮箱, 宝箱等)
        - Item (物品, 如可以右键点击打开菜单的任务物品)
        - Player (在玩家之间的 gossip 交互中)
    :param sender: 通常用于标识触发 gossip 事件的源头或者上下文. 它的具体含义可能会根据不同的情况而变化:
        - 对于 Creature（NPC）gossip：sender 通常是 NPC 的 GUID. 这可以用来确认是哪个具体的
            NPC 实例触发了事件, 特别是在有多个同类型 NPC 的情况下.
        - 对于 GameObject gossip: sender 同样可能是触发事件的游戏对象的 GUID.
        - 对于 Item gossip: sender 可能表示物品在玩家背包中的位置或者物品的 GUID.
        - 对于 Player gossip (比如玩家之间的交互): sender 可能是发起交互的玩家的 GUID.
    :param intid (number): 这是一个整数标识符, 通常用于识别玩家在 gossip 菜单中选择的特定选项.
        当你创建 gossip 菜单时, 每个选项都会被分配一个唯一的 intid. 当玩家选择一个选项时,
        这个 intid 会被传递给回调函数, 让你知道玩家选择了哪个选项.
    :param code (string): 这是一个字符串参数, 通常用于在某些特殊情况下传递额外的信息. 例如,
        如果 gossip 选项包含一个文本输入框, 玩家输入的文本会通过这个 code 参数传递给回调函数.
        在大多数简单的 gossip 交互中, 这个参数可能为空或不使用.
    :param menu_id (number): only for player gossip. Can return false to do default action.

    Ref: https://www.azerothcore.org/pages/eluna/Global/RegisterPlayerGossipEvent.html
    --]]
    --print("------ Enter function CpiMultiVendor.OnGossip() ------") -- for debug only
    --print(string.format("event = %s", event)) -- for debug only
    --print(string.format("player = %s", player)) -- for debug only
    --print(string.format("creature = %s", creature)) -- for debug only
    --print(string.format("sender = %s", sender)) -- for debug only
    --print(string.format("intid = %s", intid)) -- for debug only
    --print(string.format("code = %s", code)) -- for debug only
    --print(string.format("menu_id = %s", menu_id)) -- for debug only
    -- 第一次打开菜单, 那么就显示最顶层的菜单既可
    if event == 1 or intid == 0 then
        --print("Got: GOSSIP_EVENT_ON_HELLO event") -- for debug only
        local args = {
            sender = creature,
            player = player,
            parentVendorDataId = ROOT_VENDOR_DATA_PARENT_ID,
        }
        CpiMultiVendor.BuildMenu(
            args.sender,
            args.player,
            args.parentVendorDataId
        )
    -- 处理点击了某个菜单选项的事件. 首先我们要判断这是一个 submenu 还是一个可以立刻生效的选项
    else
        --print("Got: GOSSIP_EVENT_ON_SELECT event") -- for debug only
        local args = {
            vendorDataMapper = CpiMultiVendor.VENDOR_DATA_MAPPER,
            vendorDataKey = "id",
            vendorDataValue = intid,
        }
        local vendorDataId = CpiMultiVendor.FindIdByKeyValue(
            args.vendorDataMapper,
            args.vendorDataKey,
            args.vendorDataValue
        )
        --print(string.format("Player select the %s item", intid)) -- for debug only
        local vendorData = CpiMultiVendor.VENDOR_DATA_MAPPER[vendorDataId]
        if not vendorData then
            error("This should not happen") -- for debug only
        end
        -- 获得了被选中的 vendorData, 就进入到后续的处理逻辑
        -- 如果 vendorData 中有 data 字段, 说明被选中的事一个可以立刻生效的选项
        if vendorData.data then
            -- Ref: https://www.azerothcore.org/pages/eluna/Player/SendListInventory.html
            args = {
                sender = creature,
                vendor_id = vendorData.data.npc_id,
            }
            player:SendListInventory(
                args.sender,
                args.vendor_id
            )
            player:GossipComplete()
            --print("Exit: CpiMultiVendor.OnGossip(...)") -- for debug only
            return
        end

        --[[
        如果 vendorData 中没有 data 字段, 那么有两种情况:

        1. 这是一个 submenu 的 gossip item: 此时这个 intid 就是 submenu 的 id.
            我们将其穿给 CpiMultiVendor.BuildMenu 既可进入到下一级菜单.
        2. 这是一个 "返回 ..." 的 gossip item: 此时这个 intid 就是 parent menu 的 id.
        --]]
        args = {
            sender = creature,
            player = player,
            parentVendorDataId = intid
        }
        CpiMultiVendor.BuildMenu(
            args.sender,
            args.player,
            args.parentVendorDataId
        )
        --print("Exit: GOSSIP_EVENT_ON_SELECT branch") -- for debug only
    end
end

--[[
下面是 RegisterCreatureGossipEvent 的 event code
See: https://www.azerothcore.org/pages/eluna/Global/RegisterCreatureGossipEvent.html
--]]
RegisterCreatureGossipEvent(CPI_VENDOR_ENTRY, GOSSIP_EVENT_ON_HELLO, CpiMultiVendor.OnGossip)
RegisterCreatureGossipEvent(CPI_VENDOR_ENTRY, GOSSIP_EVENT_ON_SELECT, CpiMultiVendor.OnGossip)